package start.B001_thread;

public class A011_MESI {
//
//    本部分介绍 MESI 协议是如何解决并发中的可见性问题的，内容与Java关联有限，主要是一些计算机组成原理的知识，但和我们的主题高并发关联比较大，还是需要了解的。
//
//    为了缓解内存速度和CPU内核速度查问题，现代计算机会在CPU添加告诉缓存，每个CPU内核都有自己的一级、二级高速缓存，CPU芯片板上的CPU内核之间共享一个三级高速缓存。
//
//    每个CPU的处理过程为：先将计算需要用到的数据缓存在CPU的告诉缓存中，在CPU进行计算时，直接从高速缓存中读取数据并且在计算完成之后写回高速缓存中，在整个运算过程完成后，再把高速缓存中的数据同步到主存。
//
//    由于每个线程可能会运行在不同的CPU内核中，因此每个线程拥有自己的高速缓存。同一份数据可能会被缓存到多个CPU内核中，在不同CPU内核中运行的线程看到同一个变量的缓存值就会不一样，就可能发生内存可见性问题。
//
//    MESI协议位于硬件层，是用于解决内存的可见性问题的手段。
//
//    总线锁和缓存锁
//    为了解决内存可见性问题，CPU提供了总线锁和缓存锁。
//
//    总线锁
//    总线锁会锁住总线，通过CPU发出lock指令，总线接受到指令后，阻塞其他CPU内核的请求，直到此CPU内核执行完成。这样该CPU内核就可以独占共享内存的使用。
//
//    这种方式的缺点是一旦某个CPU内核获取总线锁，其他CPU内核都只能阻塞等待，影响多核CPU的性能。
//
//    缓存锁
//    相比总线锁，缓存锁降低了锁的粒度。为了达到数据访问一致，需要各个CPU在访问高速缓存时遵循一些协议。比如 MSI 等。
//
//    就整体而言，缓存一致性机制就是当某CPU对高速缓存中的数据进行操作之后，通知其他CPU放弃存储在他们内部的存储数据，或者从主存重新读取。
//
//    因为高速缓存的内容是部分主存内容的副本，所以应该与主存内容保持一致。而CPU对高速缓存副本如何与主存内容保持一致有几种写入模式供选择，主要的写入模式有以下两种：
//
//    Write-Through（直写）模式，在数据更新时，同时写入低一级的高速缓存和主存。
//    WriteBack（回写）模式，数据的更新并不会立即反映到主存，而是值写入高速缓存。只在数据被替换出高速缓存或者变成共享（S）状态时，如果发现数据有变动，才会将最新的数据更新到主存。
//    MSI 协议
//    MSI协议是缓存一致性协议的的基础版本，也叫作写入失效协议。如果同时有多个CPU要写入，总线会进行串行化，同一时刻只会有一个CPU获得总线的访问权。
//
//    下面是一个CPU c1、c2对变量m进行读写的例子：
//
//    CPU操作	总线操作	c1缓存内容	c2缓存内容	主存m所在地址的内容
//0
//    c1读取m	高速缓存中没有m，从主存中读取	0		0
//    c2读取m	高速缓存中没有m，从主存中读取	0	0	0
//    c1写入1到m	通知c2，使它的高速缓存中的m值失效	1		0
//    c2读取m的值	高速缓存中没有m，从c1的高速缓存中读取（采用回写模式，并且更新到主存中）	1	1	1
//    MESI 协议及 RFO 请求
//    目前主流的缓存一致性协议为MESI写入失效协议，它是MSI协议的扩展。在MESI协议中，每个缓存行（Cache Line）[1] 有4种状态，即M、E、S、I，分别代表Modified、Exclusive、Shared和Invalid，可用2bit表示。
//
//    四种状态介绍：
//
//    M（被修改）：表示缓存行数据被修改了（dirty），和内存中的数据不一致，数据只存在于本高速缓存中。
//    E（独享）：缓存行数据和内存中的数据一致（clean），数据只存在于本高速缓存中。
//    S（共享）：缓存行数据和内存中的数据一致（clean），数据存在于很多高速缓存中。
//    I（无效）：该缓存行数据是无效的。
//    四种状态的转换可以参考图7。
//
//    有关MESI协议中缓存行的状态转换的详细说明如下。
//
//    当前状态	事件	行为	下一个状态
//    I	Local Read	如果其他高速缓存没有这份数据，本高速缓存就从主存中读取数据，缓存行状态变成E	E/S
//    I		如果其他高速缓存有这份数据，且状态为M，那么将数据更新到内存，本高速缓存再从主存中读取数据，两个高速缓存的缓存行状态都变成S
//    I		如果其他高速缓存有这份数据，且状态为S或者E，本高速缓存就从主存中读取数据，两这些高速缓存的缓存行状态都变成S
//    I	Local Write	从主存中读取数据，再告诉缓存中修改，状态变成M，如果其他高速缓存有这份数据，且状态为M，那么要先将数据更新到主存	M
//    I		如果其他高速缓存有这份数据，那么其他高速缓存的缓存行状态变成I
//    I	Remote Read	既然是Invalid，别的内核操作与它无关	I
//    I	Remote Write	既然是Invalid，别的内核操作与它无关	I
//    E	Local Read	从高速缓存中读取数据，状态不变	E
//    E	Local Write	修改高速缓存中的数据，状态为M	M
//    E	Remote Read	数据和其他内核共用，状态变成了S	S
//    E	Remote Write	数据被修改，本缓存行不能再使用，状态变成1	I
//    S	Local Read	从高速缓存中的数据，状态变成M，其他内核共享的缓存行状态变成I	M
//    S	Local Write	修改高速缓存中的数据，状态变成M，其他内核共享的缓存行状态变成1	M
//    S	Remote Read	状态不变	S
//    S	Remote Write	数据被修改，本缓存行不能再使用，状态变为1
//    M	Local Read	从高速缓存中读取数据，状态不变	M
//    M	Local Write	修改高速缓存中的数据，状态不变	M
//    M	Remote Read	这行数据被写入到主存中，使其它内核能使用最新的数据，状态变成S	S
//    M	Remote Write	运行数据被写到主存中，使其它内核能使用最新的数据，由于其他内核会修改这行数据，因此状态变成I	I
//    volatile 原理
//    变量 var 添加 volatile 关键字，生成汇编后，操作 var 之前多出一个 lock 前缀指令 lock addl，该 lock 前缀指令有三个功能：
//
//    将当前CPU缓存行的数据立即写回系统内存。新版CPU中一般是通过缓存锁实现对共享内存的独占性访问，它会阻止两个CPU同时修改共享内存的数据。
//    lock前缀指令会引起在其他CPU中缓存了该内存地址的数据无效。当CPU发现自己缓存行对应的内存地址被修改时，就会将当前CPU的缓存行设置为无效状态，当CPU要对这个值进行修改时，会强制重新从系统内存中把数据读到CPU缓存。
//    lock前缀指令禁止指令重排。作为内存屏障（Memory Barrier）禁止指令重排序。
//    缓存行是高速缓存操作的基本单位，在Intel的CPU上一般是64字节。 ↩
//

//    作者：简单一点点
//    链接：https://www.jianshu.com/p/c7237bb3e261#fnref1
//    来源：简书
//    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
}
